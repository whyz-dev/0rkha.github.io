{"meta":{"title":"0rkha Blog","subtitle":null,"description":null,"author":"0rkha (GangJun Jo)","url":"http://0rkha.xyz"},"pages":[{"title":"BLOGS","date":"2019-07-28T03:10:34.000Z","updated":"2019-07-28T03:10:34.662Z","comments":true,"path":"BLOGS/index.html","permalink":"http://0rkha.xyz/BLOGS/index.html","excerpt":"","text":""},{"title":"All-Tags","date":"2020-11-16T01:58:53.446Z","updated":"2019-07-21T11:10:10.326Z","comments":false,"path":"all-tags/index.html","permalink":"http://0rkha.xyz/all-tags/index.html","excerpt":"","text":""},{"title":"All-Categories","date":"2020-11-16T01:58:53.439Z","updated":"2019-07-21T10:32:26.556Z","comments":false,"path":"all-categories/index.html","permalink":"http://0rkha.xyz/all-categories/index.html","excerpt":"","text":""},{"title":"All-Archives","date":"2022-04-15T12:22:52.997Z","updated":"2019-07-25T14:32:13.501Z","comments":false,"path":"all-archives/index.html","permalink":"http://0rkha.xyz/all-archives/index.html","excerpt":"","text":""}],"posts":[{"title":"[DevDiary] 22.12.23 ","slug":"DevDiary-22-12-23","date":"2022-12-23T13:26:37.000Z","updated":"2022-12-23T14:43:06.396Z","comments":true,"path":"2022/12/23/DevDiary-22-12-23/","link":"","permalink":"http://0rkha.xyz/2022/12/23/DevDiary-22-12-23/","excerpt":"2022.12.23","text":"개발 일지1소프트웨어 마에스트로를 준비하기로 마음먹었다. 다음 목록을 준비해야한다. 알고리즘SQLCS 면접 준비AI포트폴리오 정리자기소개서 작성 2소마 프로젝트 겸 과외 수업 자료 준비겸 문제 출제 사이트를 하나 만들기로 했다. 오늘은 친구와 커리큘럼과 출제할 문제의 유형에 대해 정리했다. 아마 정해진 유형의 문제를 골고루 랜덤하게 출제하는 기출문제식 문제 풀이 사이트가 될 듯 하다. 백엔드는 django, 프론트는 react, DB는 mysql을 생각중이다. 지금은 프로토타이핑을 하고 있다. 3종강도 했으니 슬슬 ai 공부에도 속도를 올려할 것 같다. vgg의 tensorflow 구현을 마치고, resnet을 정리해야한다. mmdetection3D를 동작시키기 위해서 준비를 해야겠다. 4혹시 시간이 날지 모르겠으나, 시간이 난다면 ai 대회를 하나 참가해야겠다.","categories":[{"name":"DevDiary","slug":"DevDiary","permalink":"http://0rkha.xyz/categories/DevDiary/"}],"tags":[{"name":"DevDiary","slug":"DevDiary","permalink":"http://0rkha.xyz/tags/DevDiary/"}],"keywords":[{"name":"DevDiary","slug":"DevDiary","permalink":"http://0rkha.xyz/categories/DevDiary/"}]},{"title":"[BOJ] 3176 | 도로 네트워크","slug":"BOJ-3176-도로-네트워크","date":"2019-08-07T14:06:00.000Z","updated":"2022-08-13T19:17:17.398Z","comments":true,"path":"2019/08/07/BOJ-3176-도로-네트워크/","link":"","permalink":"http://0rkha.xyz/2019/08/07/BOJ-3176-%EB%8F%84%EB%A1%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/","excerpt":"[BOJ] 3176 | 도로 네트워크","text":"문제https://www.acmicpc.net/problem/3176 풀이sparse table을 이용한 LCA 문제. LCA를 구현하고, 다음과 같은 DP 테이블을 만든다. maxi[i][j] &#x3D; i의 j번째 조상까지의 도로중 가장 긴 도로의 길이. maxi[i][j] &#x3D; max(maxi[parent[i][j - 1]][j - 1], maxi[i][j-1]); maxi[i][j] &#x3D; i의 j번째 조상까지의 도로중 가장 짧은 도로의 길이. mini[i][j] &#x3D; min(mini[parent[i][j - 1]][j - 1], mini[i][j - 1]); 이를 잘 이용하여 풀면 된다. sparse-table 초기화에 O(NlogN) 쿼리 실행 중, 두 노드의 높이를 맞추는데 O(logN), 가장 긴&#x2F;짧은 도로를 찾는데 O(logN)이므로, 쿼리 실행의 시간복잡도는 O(QlogN). 전체 시간복잡도는 O((Q+N)logN) 소스123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define P pair&lt;int,int&gt;using namespace std;int n, q, depth[110000], mini[110000][20], maxi[110000][20], parent[110000][20];vector&lt;P&gt; G[110000];queue&lt;int&gt; Q;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt; n; i++) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; G[a].push_back(&#123; b,c &#125;); G[b].push_back(&#123; a,c &#125;); &#125; depth[1] = 1; parent[1][0] = 1; Q.push(1); while (!Q.empty()) &#123; int now = Q.front(); Q.pop(); for (P nxt : G[now]) &#123; if (!depth[nxt.first]) &#123; depth[nxt.first] = depth[now] + 1; mini[nxt.first][0] = nxt.second; maxi[nxt.first][0] = nxt.second; parent[nxt.first][0] = now; Q.push(nxt.first); &#125; &#125; &#125; for (int i = 1; i &lt; 20; i++) for (int j = 1; j &lt;= n; j++) &#123; parent[j][i] = parent[parent[j][i - 1]][i - 1]; maxi[j][i] = max(maxi[parent[j][i - 1]][i - 1], maxi[j][i-1]); mini[j][i] = min(mini[parent[j][i - 1]][i - 1], mini[j][i - 1]); &#125; cin &gt;&gt; q; while (q--) &#123; int a, b, dismax=0, dismin=1000000; cin &gt;&gt; a &gt;&gt; b; if (depth[a] &lt; depth[b]) swap(a, b); int diff = depth[a] - depth[b]; for(int i=0; diff; i++) &#123; if (diff &amp; 1) &#123; dismax = max(dismax, maxi[a][i]); dismin = min(dismin, mini[a][i]); a = parent[a][i]; &#125; diff /= 2; &#125; if (a != b) &#123; for (int i = 19; i &gt;= 0; i--) &#123; if (parent[a][i] != parent[b][i]) &#123; dismax = max(&#123; dismax, maxi[a][i], maxi[b][i] &#125;); dismin = min(&#123; dismin, mini[a][i], mini[b][i] &#125;); a = parent[a][i], b = parent[b][i]; &#125; &#125; dismax = max(&#123; dismax, maxi[a][0], maxi[b][0] &#125;); dismin = min(&#123; dismin, mini[a][0], mini[b][0] &#125;); &#125; cout &lt;&lt; dismin &lt;&lt; &quot; &quot; &lt;&lt; dismax &lt;&lt; &quot;\\n&quot;; &#125;&#125;","categories":[{"name":"PS","slug":"PS","permalink":"http://0rkha.xyz/categories/PS/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"http://0rkha.xyz/tags/BOJ/"},{"name":"DP","slug":"DP","permalink":"http://0rkha.xyz/tags/DP/"},{"name":"LCA","slug":"LCA","permalink":"http://0rkha.xyz/tags/LCA/"}],"keywords":[{"name":"PS","slug":"PS","permalink":"http://0rkha.xyz/categories/PS/"}]},{"title":"[BOJ] 5419 | 북서풍","slug":"BOJ-5419-북서풍","date":"2019-08-07T13:01:09.000Z","updated":"2022-08-13T19:17:15.706Z","comments":true,"path":"2019/08/07/BOJ-5419-북서풍/","link":"","permalink":"http://0rkha.xyz/2019/08/07/BOJ-5419-%EB%B6%81%EC%84%9C%ED%92%8D/","excerpt":"[BOJ] 5419 | 북서풍","text":"문제https://www.acmicpc.net/problem/5419 풀이임의의 한 섬(a,b)을 기준으로, 그 점과 이어질 수 있는 섬(c,d)들은 모두 a&lt;&#x3D;c와 b&gt;c를 만족해야한다. 이를 이용하여, y축을 기준으로 오름차순으로 정렬하고, y축이 같은 경우는 x기준으로 내림차순으로 정렬하면, 아무 섬이나 잡아도, 해당 섬 이전에 선택된 섬들은 모두 해당 섬보다 남쪽에 있을 것임이 자명하다.또한 이전에 선택된 섬들 중에, 해당 섬보다 동쪽에 있는 섬들의 개수를 세주면, 해당 섬보다 남쪽에 있으면서 동쪽에 있는 섬들을 모두 선택할 수 있게 된다. 단, 좌표가 -10^9~10^9이므로, O(N)으로 가능한 X좌표들을 모두 저장해두고, 이분 탐색으로 index 위치를 찾는다. 섬들의 개수는 세그먼트 트리로 O(logN)만에 구할 수 있으며, 개수 업데이트에 O(logN), 이분 탐색에 O(logN)이므로, 모든 점 탐색은O(NlogN)만에 가능하다. 소스12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#define P pair&lt;int,int&gt;using namespace std;int tree[400000], num[80000], MAX, T,N;bool cmp1(P a, P b) &#123; return a.first &lt; b.first; &#125;bool cmp2(P a, P b) &#123; return (a.second == b.second) ? (a.first &gt; b.first):(a.second &lt; b.second); &#125;void update(int p, int v) &#123; p += MAX; tree[p] += v; for (; p /= 2; tree[p] = tree[2 * p] + tree[2 * p + 1]);&#125;int sum(int s, int e) &#123; int res = 0; s += MAX, e += MAX; while (s &lt; e) &#123; if (s % 2) res += tree[s++]; if (e % 2 == 0) res += tree[e--]; s /= 2, e /= 2; &#125; if (e == s) res += tree[s]; return res;&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; T;; while (T--) &#123; long long size = 0, res=0; vector&lt;P&gt; V; cin &gt;&gt; N; for (MAX = 1; MAX &lt; N; MAX *= 2); memset(tree, 0, sizeof(tree)); memset(num, 0, sizeof(num)); for (int i = 0; i &lt; N; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; V.push_back(&#123; x,y &#125;); &#125; sort(V.begin(), V.end(), cmp1); for (int i = 0; i &lt; V.size(); i++) &#123; if (!i || num[size] != V[i].first) num[size++] = V[i].first; &#125; sort(V.begin(), V.end(), cmp2); for (P idx : V) &#123; int l = 0, r = size-1; while (l &lt; r) &#123; int m = (l + r) / 2; if (num[m] &gt; idx.first) r = m - 1; else if (num[m] &lt; idx.first) l = m + 1; else &#123; l = m; break; &#125; &#125; res += sum(l, size); update(l, 1); &#125; cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;; &#125;&#125;","categories":[{"name":"PS","slug":"PS","permalink":"http://0rkha.xyz/categories/PS/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"http://0rkha.xyz/tags/BOJ/"},{"name":"segment-tree","slug":"segment-tree","permalink":"http://0rkha.xyz/tags/segment-tree/"},{"name":"binary-search","slug":"binary-search","permalink":"http://0rkha.xyz/tags/binary-search/"},{"name":"line-sweeping","slug":"line-sweeping","permalink":"http://0rkha.xyz/tags/line-sweeping/"}],"keywords":[{"name":"PS","slug":"PS","permalink":"http://0rkha.xyz/categories/PS/"}]},{"title":"[BOJ] 13537 | 수열과 쿼리 1","slug":"BOJ-13537-수열과-쿼리-1","date":"2019-08-01T14:04:48.000Z","updated":"2022-08-13T19:17:08.516Z","comments":true,"path":"2019/08/01/BOJ-13537-수열과-쿼리-1/","link":"","permalink":"http://0rkha.xyz/2019/08/01/BOJ-13537-%EC%88%98%EC%97%B4%EA%B3%BC-%EC%BF%BC%EB%A6%AC-1/","excerpt":"[BOJ] 13537 | 수열과 쿼리 1","text":"문제https://www.acmicpc.net/problem/13537 풀이수열을 다음과 같은 업데이트 쿼리로 해석한다. a b : 위치가 a인 위치를 b로 교체 그리고 쿼리 (i j k)를 k에 대해 내림차순으로 정렬한다. 업데이트 쿼리들도 마찬가지로, b에 대해 내림차순으로 정렬한다. 그리고, k&gt;b를 만족할때, 세그먼트 트리에서 위치가 a인 곳에 1을 업데이트 한다. 그러면, 트리에서 i부터 j까지의 합이 쿼리 (i j k)에 대한 답변이 된다. 출력할때도, 쿼리의 입력순으로 정렬해주자. 소스12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;functional&gt;#define ll long longusing namespace std;struct _ &#123; ll idx, i, j, k; &#125;;bool operator&lt;(_ a, _ b) &#123; return a.k &gt; b.k; &#125;vector&lt;_&gt; query;vector&lt;pair&lt;ll, ll&gt; &gt;arr, ans;ll N, MAX, tree[400000], M;void update(ll p, ll v) &#123; p += MAX; tree[p] = v; for (; p /= 2; tree[p] = tree[2 * p] + tree[2 * p + 1]);&#125;ll sum(ll s, ll e) &#123; ll res = 0; s += MAX, e += MAX; while (s &lt; e) &#123; if (s % 2) res += tree[s++]; if (e % 2 == 0) res += tree[e--]; e /= 2; s /= 2; &#125; if(s==e) res += tree[e]; return res;&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; N; for (MAX = 1; MAX &lt; N; MAX *= 2); for (int i = 1; i &lt;= N; i++) &#123; ll tmp; cin &gt;&gt; tmp; arr.push_back(&#123; tmp,i &#125;); &#125; cin &gt;&gt; M; for (int i = 0; i &lt; M; i++) &#123; ll a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; query.push_back(&#123; i,a,b,c &#125;); &#125; sort(arr.begin(), arr.end(), greater&lt;pair&lt;ll, ll&gt; &gt;() ); sort(query.begin(), query.end()); ll now = 0; for (auto idx : query) &#123; while (now &lt; arr.size() &amp;&amp; idx.k &lt; arr[now].first) &#123; update(arr[now].second, 1); now++; &#125; ans.push_back(&#123; idx.idx, sum(idx.i,idx.j) &#125;); &#125; sort(ans.begin(), ans.end()); for (auto idx : ans) cout &lt;&lt; idx.second &lt;&lt; &quot;\\n&quot;;&#125;","categories":[{"name":"PS","slug":"PS","permalink":"http://0rkha.xyz/categories/PS/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"http://0rkha.xyz/tags/BOJ/"},{"name":"segment_tree","slug":"segment-tree","permalink":"http://0rkha.xyz/tags/segment-tree/"},{"name":"sort","slug":"sort","permalink":"http://0rkha.xyz/tags/sort/"}],"keywords":[{"name":"PS","slug":"PS","permalink":"http://0rkha.xyz/categories/PS/"}]},{"title":"[BOJ] 2436 | 공약수","slug":"BOJ-2436-공약수","date":"2019-07-28T03:10:00.000Z","updated":"2022-08-13T19:17:19.810Z","comments":true,"path":"2019/07/28/BOJ-2436-공약수/","link":"","permalink":"http://0rkha.xyz/2019/07/28/BOJ-2436-%EA%B3%B5%EC%95%BD%EC%88%98/","excerpt":"[BOJ] 2436 | 공약수","text":"문제https://www.acmicpc.net/problem/2436 출처 KOI 2011 초등부 2번 KOI 2011 중등부 1번 KOI 2011 고등부 1번 풀이유클리드 호제법 (최대공약수 구하기) :https://ko.wikipedia.org/wiki/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C_%ED%98%B8%EC%A0%9C%EB%B2%95 여기서는 두 입력으로 최대공약수와 최소공배수를 준다. 두 수를 각 a와 b라고 할때, LCM을 다음과 같이 나타낼 수 있다. LCM &#x3D; a*b&#x2F;GCD 이를 정리하면, GCD * LCM &#x3D; a*b 이를 이용하여 시간복잡도 O(sqrt(GCD*LCM)) &#x3D; O(sqrt(a*b))만에 풀 수 있다. 입력이 1억이니, int 범위 초과에 주의하자. 소스123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;long long GCD, LCM, mul, a, b, flag;long long gcd(long long a, long long b) &#123; return b ? gcd(b, a%b) : a;&#125;int main() &#123; cin &gt;&gt; GCD &gt;&gt; LCM; mul = GCD * LCM; a = 1; b = LCM; for (int i = 1; i &lt;= mul / i; i++) &#123; if (mul%i || gcd(i, mul / i) != GCD) continue; flag = 1; a = i, b = mul / i; &#125; if(flag) cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b;&#125;","categories":[{"name":"PS","slug":"PS","permalink":"http://0rkha.xyz/categories/PS/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"http://0rkha.xyz/tags/BOJ/"},{"name":"KOI","slug":"KOI","permalink":"http://0rkha.xyz/tags/KOI/"},{"name":"Euclidean-algorithm","slug":"Euclidean-algorithm","permalink":"http://0rkha.xyz/tags/Euclidean-algorithm/"}],"keywords":[{"name":"PS","slug":"PS","permalink":"http://0rkha.xyz/categories/PS/"}]},{"title":"[BOJ] 11047 | 동전 0","slug":"BOJ-11047-동전-0","date":"2019-07-26T13:55:16.000Z","updated":"2022-08-13T19:17:13.484Z","comments":true,"path":"2019/07/26/BOJ-11047-동전-0/","link":"","permalink":"http://0rkha.xyz/2019/07/26/BOJ-11047-%EB%8F%99%EC%A0%84-0/","excerpt":"[BOJ] 11047 | 동전 0","text":"문제https://www.acmicpc.net/problem/11047 풀이문제를 읽어보면, “A_1 &#x3D; 1, i ≥ 2인 경우에 A_i는 A_{i-1}의 배수”라는 조건이 있는데, 첫번째 조건을 통해, “만들지 못하는 경우는 없다.”를 추측해낼 수 있고, 두번째 조건을 통해, “tA_{i-1}는 A_i로 대체할 수 있다.”를 추측해낼 수 있다. (t는 임의의 상수) 가치가 A_i인 동전을 가치가 A_{i-1}동전으로 대체할 수 있으나, 가치가 A_{i-1}를 여러개 쓰는 것 보다, 가치가 A_i인 큰 동전 하나로 바꾸는게 이득이라는 것을 알 수 있다. 이렇게 가장 큰 동전부터 사용하여, greedy한 방법으로 정답을 찾을 수 있다. 시간복잡도는 동전의 개수, 즉 O(N)이다. 소스12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int n, k, cnt, coin[11];int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;=n; i++) cin &gt;&gt; coin[i]; while (n) &#123; if (coin[n] &gt; k) &#123; n--; continue; &#125; cnt += k / coin[n]; k %= coin[n]; &#125; cout &lt;&lt; cnt;&#125;","categories":[{"name":"PS","slug":"PS","permalink":"http://0rkha.xyz/categories/PS/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"http://0rkha.xyz/tags/BOJ/"},{"name":"greedy","slug":"greedy","permalink":"http://0rkha.xyz/tags/greedy/"}],"keywords":[{"name":"PS","slug":"PS","permalink":"http://0rkha.xyz/categories/PS/"}]},{"title":"[BOJ] 2294 | 동전 2","slug":"BOJ-2294-동전-2","date":"2019-07-26T13:32:25.000Z","updated":"2022-08-13T19:17:21.618Z","comments":true,"path":"2019/07/26/BOJ-2294-동전-2/","link":"","permalink":"http://0rkha.xyz/2019/07/26/BOJ-2294-%EB%8F%99%EC%A0%84-2/","excerpt":"[BOJ] 2294 | 동전 2","text":"문제https://www.acmicpc.net/problem/2294 풀이https://www.acmicpc.net/problem/2293을 풀면 사고를 확장하여 쉽게 풀 수 있다. DP[i]를 i번 동전을 만들 수 있는 최소 횟수라고 정의하면, DP[i] &#x3D; max(DP[i], DP[ i - coin[j] ] + 1), j &#x3D; 0~n-1 로 정리된다. 위 점화식을 그대로 적용하면 AC를 받게된다. 시간복잡도는 동전 1과 같은 O(NM). 소스1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;algorithm&gt;#define MAX 10000001using namespace std;int n, k, dp[10010], coin[101];int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt;n; i++) cin &gt;&gt; coin[i]; for (int i = 1; i &lt;= k; i++) dp[i] = MAX; sort(coin, coin + n); for (int j = 0; j &lt; n; j++) for (int i = 1; i &lt;= k; i++) if (i &gt;= coin[j]) dp[i] = min(dp[i - coin[j]]+1, dp[i]); if (dp[k] == MAX) cout &lt;&lt; -1; else cout &lt;&lt; dp[k];&#125;","categories":[{"name":"PS","slug":"PS","permalink":"http://0rkha.xyz/categories/PS/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"http://0rkha.xyz/tags/BOJ/"},{"name":"DP","slug":"DP","permalink":"http://0rkha.xyz/tags/DP/"}],"keywords":[{"name":"PS","slug":"PS","permalink":"http://0rkha.xyz/categories/PS/"}]},{"title":"[BOJ] 1451 | 직사각형으로 나누기","slug":"BOJ-1451-직사각형으로-나누기","date":"2019-07-26T09:54:32.000Z","updated":"2022-08-13T19:17:40.274Z","comments":true,"path":"2019/07/26/BOJ-1451-직사각형으로-나누기/","link":"","permalink":"http://0rkha.xyz/2019/07/26/BOJ-1451-%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95%EC%9C%BC%EB%A1%9C-%EB%82%98%EB%88%84%EA%B8%B0/","excerpt":"[BOJ] 1451 | 직사각형으로 나누기","text":"문제https://www.acmicpc.net/problem/1451 풀이 가능한 6가지 경우의 수를 생각하여 모든 경우의 수를 계산해주면 된다. 직사각형의 넓이를 구할때는 구간 합(prefix sum)을 이용하여 O(1)에 계산해줄 수 있다. 두 직사각형 사이에 한 직사각형이 껴있는 경우의 시간복잡도는 각각 O(N^2)과 O(M^2), 나머지 경우의 수는 시간복잡도가 O(NM)이므로, 대충 전체 시간복잡도는 O(NM). 소스123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;long long N, M, arr[111][111], sum[111][111], ans;int main() &#123; scanf(&quot;%d%d&quot;, &amp;N, &amp;M); for (int i = 1; i &lt;= N; i++) for (int j = 1; j &lt;= M; j++) &#123; scanf(&quot;%1d&quot;, &amp;arr[i][j]); sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + arr[i][j]; &#125; for (int i = 1; i &lt; N; i++) for (int j = 1; j &lt; M; j++) &#123; long long a, b, c; a = sum[i][j]; b = sum[N][j] - sum[i][j]; c = sum[N][M] - sum[N][j]; ans = max(ans, a*b*c); b = sum[i][M] - sum[i][j]; c = sum[N][M] - sum[i][M]; ans = max(ans, a*b*c); a = sum[N][M] - sum[N][j] - sum[i][M] +sum[i][j]; b = sum[N][j]; c = sum[i][M] - sum[i][j]; ans = max(ans, a*b*c); b = sum[i][M]; c = sum[N][j] - sum[i][j]; ans = max(ans, a*b*c); &#125; for (int i = 1; i &lt; N; i++) for (int j = i + 1; j &lt; N; j++) ans = max(ans, sum[i][M] * (sum[j][M] - sum[i][M]) *(sum[N][M] - sum[j][M])); for (int i = 1; i &lt; M; i++) for (int j = i + 1; j &lt; M; j++) ans = max(ans, sum[N][i] * (sum[N][j] - sum[N][i]) *(sum[N][M] - sum[N][j])); cout &lt;&lt; ans;&#125;","categories":[{"name":"PS","slug":"PS","permalink":"http://0rkha.xyz/categories/PS/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"http://0rkha.xyz/tags/BOJ/"},{"name":"brute-force","slug":"brute-force","permalink":"http://0rkha.xyz/tags/brute-force/"},{"name":"prefix-sum","slug":"prefix-sum","permalink":"http://0rkha.xyz/tags/prefix-sum/"}],"keywords":[{"name":"PS","slug":"PS","permalink":"http://0rkha.xyz/categories/PS/"}]},{"title":"[BOJ] 2293 | 동전 1","slug":"BOJ-2293-동전-1","date":"2019-07-26T07:38:33.000Z","updated":"2022-08-13T19:17:26.298Z","comments":true,"path":"2019/07/26/BOJ-2293-동전-1/","link":"","permalink":"http://0rkha.xyz/2019/07/26/BOJ-2293-%EB%8F%99%EC%A0%84-1/","excerpt":"[BOJ] 2293 | 동전 1","text":"문제https://www.acmicpc.net/problem/2293 풀이DP를 사용하여 풀 수 있는 간단한 문제. DP[i] &#x3D; 가격이 i일때 만들 수 있는 모든 경우의 수 DP[i] +&#x3D; DP[ i - coin[j] ], (j &#x3D; 0~n-1) 따라서 전체 시간복잡도는 O(nk)가 된다. DP의 점화식을 2차원으로 세우면 메모리 초과가 나므로, 위와같은 1차원으로 짜주어야 한다. for문을 돌 때, 가격이 i일때 경우의수를 0~n-1까지 도는 것이 아니라, 물건 번호가 j일때 가격을 1~k까지 DP를 업데이트 하는것에 주의하자. 소스123456789101112131415161718#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n, k, dp[10010], coin[101];int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt;n; i++) cin &gt;&gt; coin[i]; dp[0] = 1; sort(coin, coin + n); for (int j = 0; j &lt; n; j++) for (int i = 1; i &lt;= k; i++) if (i &gt;= coin[j]) dp[i] += dp[i - coin[j]]; cout &lt;&lt; dp[k];&#125;","categories":[{"name":"PS","slug":"PS","permalink":"http://0rkha.xyz/categories/PS/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"http://0rkha.xyz/tags/BOJ/"},{"name":"DP","slug":"DP","permalink":"http://0rkha.xyz/tags/DP/"}],"keywords":[{"name":"PS","slug":"PS","permalink":"http://0rkha.xyz/categories/PS/"}]},{"title":"Intro","slug":"이-블로그에-대하여","date":"2019-07-21T12:10:33.000Z","updated":"2022-08-13T19:20:36.269Z","comments":true,"path":"2019/07/21/이-블로그에-대하여/","link":"","permalink":"http://0rkha.xyz/2019/07/21/%EC%9D%B4-%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/","excerpt":"안녕하세요, 0rkha입니다. 오늘 2019&#x2F;07&#x2F;21을 기준으로 새로운 깃허브 블로그를 개설하게 되었습니다.","text":"안녕하세요, 0rkha입니다. 오늘 2019&#x2F;07&#x2F;21을 기준으로 새로운 깃허브 블로그를 개설하게 되었습니다. 아마 머신러닝과 딥러닝, 알고리즘 등의 데이터 사이언스 부분의 포스팅을 주로 하게 될것 같습니다. 블로그의 테마는 LouisBarranqueiro의 tranquilpeak를 이용하여 수정하였습니다. 게시글에 대하여 궁금한 점이나 개인적으로 연락하시고 싶으시면, &#52;&#x75;&#x72;&#x61;&#x30;&#50;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d; 으로 메일을 보내주시면 감사하겠습니다.","categories":[],"tags":[{"name":"etc","slug":"etc","permalink":"http://0rkha.xyz/tags/etc/"}],"keywords":[]}]}